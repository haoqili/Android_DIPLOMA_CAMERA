**NOTE** Currently I'm using "DIPLOMA" most of the time to refer to the app that uses DIPLOMA, not DIPLOMA itself!

Order:
X1. Camera_DIPLOMA take
X2. Camera_CLOUD
3. Trials + heartbeat/talking section of DIPLOMA overview
4. screen shot DDSM / UI writing
5. DIPLOMA overview (introduces region leader relaying/hopping, consistent shared memory among region, heartbeats/talking to cloud detailed enough for the trials section, or write it along with the trials section)

Camera_DIPLOMA app details
--------------------------

The Camera_DIPLOMA app utilizes the DIPLOMA for inter-region communication, but has a custom intra-region communication between a region's leader and nonleader as well as tasks carried out at remote region's leaders. Figure # categorizes all the java file that Camera_DIPLOMA app uses by assigning each file as DIPLOMA or app-specific.

Figure #
-------------------------
|   File Name                           DIPLOMA or app*     lines**     Description
-------------------------
|   Atom.java                           DIPLOMA             100         DIPLOMA inter-region communication request or reply (leader 1 <---> leader 2)
|   CameraSurfaceView.java              app                 100         camera UI
|   Cloud.java                          DIPLOMA             150         HTTP requests to the cloud to keep states consistent
|   DSMLayer.java                       DIPLOMA             500         ????? TODO
|   DSMUser.java                        DIPLOMA              10         ????? TODO
|   GetPhotoInfo.java                   app                  20         packet inside Packet that congregates photo-request information to persist through all legs of the requestA
|   Globals.java                        app                  70         global variables 
|   HysteresisSpinnerListener.java      app                  20         UI, to set width of hysteresis in real-life deployment
|   Mux.java                            DIPLOMA/app         300         sort requests heard
|   NetworkThread.java                  DIPLOMA             200         DIPLOMA sending requests
|   Packet.java                         DIPLOMA/app          80         Wifi packet for intra-region communication (nonleader <---> leader)
|   RegionKey.java                      DIPLOMA              50         Region key class
|   *StatusActivity.java*               app                1200         Where the app starts. UI of app. Run on client-side of app (sends requests and hear leader responses).***
|   *UserApp.java*                      app                 550         Run on leader-side of app, have a local-leader section and a remote-leader section 
|   VCoreDaemon.java                    DIPLOMA            1000         Keeping DIPLOMA alive and consistent through heartbeats, state-switches, and movements of phones
|------------------
|   Total                                                  4400
|------------------
    * DIPLOMA/app means the file is mainly DIPLOMA, but modified for the app
    ** Rounded
    *** Leader phones also have a client side because they have to make requests too, so StatusActivity is run on all phones.

To read more about DIPLOMA, please refer to [TODO: insert Jason's paper]. The most important app files are StatusActivity.java and UserApp.java. 

StatusActivity.java contains three important components: onCreate(), button onClickListeners, and its message handler. The one and only activity of the app is initialized in the onCreate() function of StatusActivity.java. Inside onCreate(), UI elements are linked to their click listeners and the Mux is started in order to sort requests that the phone hears (Mux is described in detail later). The various onClickListeners can be viewed as the "client-side" of the app, generating different requests to be sent through DIPLOMA. The requests' replies are processed inside the message handler, the last important component of StatusActivity.java.

UserApp.java can be viewed as the "server-side" of the app, running only on region leader phones. Different legs of the request activate different functions inside UserApp. These functions as well as the crucial functions StatusActivity are best understood through an example, walking through chronologically a scenario of a remote region _get_.

#########################################################
#########################################################


Camera_DIPLOMA Scenario 1. Non-leader of region 1 taking a photo
------
Phone A: request originator, in this scenario a non-leader of region 1
Phone B: leader of Phone A's region, in this scenario, region 1's leader

Phone A:
1. User presses the "Take Photo" button on Phone A. 
2. StatusActivity.java: my_camera_button OnClickListener() 
        registers the button press and disable all other button presses with ProgressDialog until response is received in step 28.
3. StatusActivity.java: HandlePictureStorage() gets the byte array of the photo, compresses it, set it into a Wifi packet (First-leg Wifi packet) that is broadcasted in the local region (1), which should be picked up by the local region leader. 
4.      The Wifi packet is saved to the global `requestPacket` 
5. StatusActivity.java: sendRequestPacketRepeatingRunnable sends `requestPacket` to mux 4 times (4 = 1 + sendingRequestsTimeoutPeriod/sendingRequestsPeriod) or StatusActivity's handler hears a first-leg ack from the local leader. The repetition increases the chance of success when Wifi is spotty. Right before the Wifi packet is sent, the time is recoreded as the start time for the request latency calculation.

* First Leg: *      Phone A --- Wifi ---> Phone B
                 originator --- Wifi ---> local leader
                            First-leg Wifi packet:
                            - type: Packet.CLIENT_REQUEST
                            - subtype: Packet.CLIENT_UPLOAD_PHOTO
                            - a unique requestCounter based on the IP address (mId) of Phone A
                            - a byte stream of a GetPhotoInfo object for tracking, throughout different stages of the request
                              GetPhotoInfo object:
                                - originNodeId: the IP address (mId) of Phone A
                                - srcRegion: source region of Phone A (1)
                                - destRegion: destination region, same as source (1))
                                - requestCtr: the unique requestCounter 
                                - photoBytes: set to bytes of picture

Phone B:
5. Mux.java processMessage() hears the message, figures out that it has `case Packet.CLIENT_REQUEST`, and forwards the package to UserApp's handleClientRequest.
6. UserApp.java: handleClientRequest()
        is used by a leader to handle the first-leg of the request initiated by one of its non-leaders. First, handleClientRequest() makes sure that the Wifi packet is in fact from its own region and then it makes sure that the requestCounter of the Wifi packet has not been encountered before.
7.      After making sure that the Wifi packet is new, different actions are taken based on the subtype of the Wifi packet. 
8.      In our case of Packet.CLIENT_UPLOAD_PHOTO, a DIPLOMA atom request, with procedure `SERVER_UPLOAD_PHOTO`, is made and sent to the destination region, which is itself, through DIPLOMA. The atom request also contains the unmodified GetPhotoInfo bytes from the Wifi packet.
9.      A first-leg ack is sent to Phone A through a new Wifi packet. If this ack is lost or if the first leg failed, Phone A's StatusActivity.java will repeatly send the first leg Wifi packet 4 times (see step 5) or until its StatusActivity hears this first-leg ack.
            First-leg ack Wifi packet:
                - type: Packet.SERVER_REPLY
                - subtype: Packet.SERVER_FIRST_LEG_ACK

* Second Leg: *                           Phone B --- DIPLOMA ---> Phone B
                                     local leader --- DIPLOMA ---> remote leader = local leader
                                                  Second-leg DIPLOMA atom request:
                                                  - procedure: SERVER_UPLOAD_PHOTO
                                                  - GetPhotoInfo object
                                                        - same as First-leg Wifi packet's GetPhotoInfo object

Phone B:
10. Through DIPLOMA, the atom request is sent to Phone B itself.
11. UserApp.java: handleDSMRequest()
        executes the user request. Different tasks are performed depending on what the atom request procedure is. A user request of getting photos correspond to the SERVER_UPLOAD_PHOTO procedure.
12.     Inside the case SERVER_UPOLAD_PHOTO, Phone B retrieves the photo byte array from the DIPLOMA atom request GetPhotoInfo's photoBytes. This array is then saved into the region's consistent shared memory: blocks.lines (see DSMLayer.java for details). Since block.lines is a hash map, all photo data are grouped under the same key, `Globals.PHOTO_KEY`. This key then points to the ArrayList of photos, where we get the newest photo. Currently there is only one element in the ArrayList that is constantly updated to contain the newest photo of the region.  
        Since only the newest photo of the region is ever retrieved, it might seem strange that only the first element of the photo Arraylist is updated. Initially, the app's UI was designed to be able to retrieve the ith newest photo. So it is indeed superfluous to store the newest photo's byte array in an Arraylist, but this design allows a simpler change if in the future the app should save multiple photos.
13.     The leader displays this newly saved photo on the UI through a SERVER_SHOW_NEWPHOTO packet.
14.     GetPhotoInfo bytes will be sent back in DIPLOMA to the local leader (itself) and the client side (StatusActivity) of the originator phone. Since photoBytes are no longer needed in StatusActivity, it is set to null to decrease the size of the DIPLOMA atom reply.
15.     A DIPLOMA atom reply is made with the same procedure as the atom request (`SERVER_UPLOAD_PHOTO`), but reversed destination and source regions. The atom reply also contains the modified version of the atom request's GetPhotoInfo, with photoBytes set to null. This atom reply is send from the remote leader back to the local leader, the same phone, through DIPLOMA, as the third leg of the request.

* Third Leg: *                           Phone B <--- DIPLOMA --- Phone B
                                    local leader <--- DIPLOMA --- remote leader = local leader
                                                  Third-leg DIPLOMA atom reply:
                                                  - procedure: SERVER_GET_PHOTO
                                                  - GetPhotoInfo object:
                                                        - same information as First-leg Wifi packet's GetPhotoInfo object
                                                        - photoBytes: null
                                                        - isSuccess: true for successful save

Phone B:
16. UserApp.java: handleDSMReply() of the local leader (Phone B)
        processes the Atom reply from the the remote leader (Phone B) to figure out a) the IP address of the original phone and b) whether the atom request timed out (even though it's from the same phone, the function is written generically that it works both for GET and TAKE)
17.     a) The original phone's IP address is extracted from the atom reply GetPhotoInfo object's originNodeId field. The IP address is required to send a final Wifi packet back to the originator phone node. This Wifi packet contains the same GetPhotoInfo objects as the atom reply with the addition of the isSuccess field set to indicate whether the atom request timed out.
18.     b) An atom request times out if the local leader (Phone B) cannot reach the remote leader (Phone C) with DIPLOMA, in which case the local leader will send a fake self reply with the reply atom's `timedOut` field set to `true` (see DSMLayer.java). (This timed out case is not represented by the above Third Leg diagram, the DIPLOMA atom reply would be a self-loop on the local leader instead.) When a reply is detected to be timedOut inside handleDSMReply(), the GetPhotoInfo object's isSuccess is set to false.
19.     A reply counter is constructed based on the request counter to keep track of all the Wifi reply packets.
20.     From the procedure of the atom reply, handleDSMReply() sets subtype of the final Wifi reply packet.
21.     The Wifi reply is put into a hash map, `replyPacketMap`, to repeatedly send a reply until the originator acknowledges its acceptance.
22.     The Wifi reply is send through the `sendReplies` function.
23. UserApp.java: sendReplies() is a function to send Wifi replies every sendingRepliesPeriod until Phone B receives the final leg ack from the client or the sendingRepliesTimeoutPeriod is reached. 
24.     The only parameter of `sendReplies()` is the reply counter, which is used to create two custom runnables, one for the reply, one for the reply timeout. The functions createReplyRepeatingRunnable() and create ReplyTimeoutR() are basically runnable wrappers to make the runnables take in different reply counter parameters.
25. UserApp.java: createReplyRepeatingRunnable() retrieves the Wifi packet from the hash map to finally send it. At the end of the function it posts itself to the handler to be called every sendingRepliesPeriod.

* Fourth Leg: *     Phone A <--- Wifi --- Phone B
                 originator <--- Wifi --- local leader
                            Fourth-leg/Final Wifi packet:
                            - type: Packet.SERVER_REPLY
                            - subtype: Packet.CLIENT_UPLOAD_PHOTO_ACK
                            - a unique requestCounter based on the IP address (mId) of Phone A
                            - a unique replyCounter based on requestCounter
                            - a byte stream of a GetPhotoInfo object for tracking, throughout different stages of the request
                              GetPhotoInfo object:
                                - same information as Third-leg DIPLOMA packet's GetPhotoInfo object
                                - isSuccess: false if DILPOMA level timed out

Phone A:
26. StatusActivity.java: myHandler handleMessage() 
        receives messages from its Mux and sorts the packets by its subtype.
27.     In our case of CLIENT_UPLOAD_PHOTO_ACK, first the current time is noted to calculate the latency by subtracting the start time from step 5.
28.     Remove the timeout runnable and enable button presses again.
29. StatusActivity.java: finalLegAck()
        The final leg ack is sent to Phone B, the local leader, through a new Wifi packet. If this ack is lost or if the first leg failed, Phone B's reply repeating runnable (step 25.) repeatly send the final Wifi packet until the sendingRepliesTimeoutPeriod is reached or it hears this final-leg ack. This final leg ack is sent even for duplicated Final Wifi packets received, such as in the case of a previously lost final leg ack.
            Final-leg ack Wifi packet:
                - type: Packet.CLIENT_REQUEST
                - subtype: Packet.CLIENT_FINAL_LEG_ACK
                - a unique requestCounter based on the IP address (mId) of Phone A
                - the replyCounter received from the Final Wifi packet
30. StatusActivity.java: myHandler handleMessage() case CLIENT_UPLOAD_PHOTO_ACK
        The packet reply counter is checked with an array list of processed reply counters. If found, that means the packet is a duplicate. Else, the reply counter is added to the array list and the packet proceeds to be processed.
31.     The GetPhotoInfo object from the packet contains the `isSuccess` field that tells whether the packet timed out at DIPLOMA or not. If so, we increment the counter for "bad" requests, `getBad`.
32.     As long as DIPLOMA did not time out, the counter for successful requests, `getGood`, is incremented.

Phone A does not receive reply from Phone B:
33. StatusActivity.java: buttonEnableProgressUploadTimeoutR
        There are times when the local leader is not available, possibly due to the leader switching regions but before a new leader is elected or sometimes the Wifi connection is not consistent. In such cases, the originator may never hear a reply from the local leader, i.e. Phone A never receives  the fourth and final leg Wifi Packet. Since UI is blocked as soon as buttons are pressed (step 2), this timeout is set up to enable the UI buttons again as well as record down the number of time outs in counter `getTimedout`.


#########################################################
#########################################################

Camera_DIPLOMA Scenario 2. Leader of region 1 take a photo
------
Phone B: request originator is the leader of region 1 in this scenario

The entire walkthrough is the same as Scenario 1, except "Phone A"'s StatusActivity roles are also run on Phone B, which is already performing the leader UserApp roles. See the following diagram:

                        Phone A/nonleader       Phone B/leader      Phone B/leader
                        StatusActivity          StatusActivity      UserApp
        Scenario 1          active                                      active
        Scenario 2                                  active              active

Wifi Packets are not sent over the Wifi but are conveniently treated as received packets in Mux.


#########################################################
#########################################################


Camera_DIPLOMA Scenario 3. Non-leader of region 1 getting region 5's photo. 
------
Phone A: request originator, in this scenario a non-leader of region 1
Phone B: leader of Phone A's region, in this scenario, region 1's leader
Phone C: leader of remote region, in this scenario, region 5's leader

Phone A:
1. User presses the "Get 5 Photo" button on Phone A. 
2. StatusActivity.java: get_button_listener OnClickListener() 
        registers the button press and knows the destination region is 5 and disable all other button presses with ProgressDialog until response is received in step 28.
3.      and creates a Wifi packet (First-leg Wifi packet) that is broadcasted in the local region (1), which should be picked up by the local region leader. 
4.      The Wifi packet is saved to the global `requestPacket` 
5. StatusActivity.java: sendRequestPacketRepeatingRunnable sends `requestPacket` to mux 4 times (4 = 1 + sendingRequestsTimeoutPeriod/sendingRequestsPeriod) or StatusActivity's handler hears a first-leg ack from the local leader. The repetition increases the chance of success when Wifi is spotty. Right before the Wifi packet is sent, the time is recoreded as the start time for the request latency calculation.

* First Leg: *      Phone A --- Wifi ---> Phone B
                 originator --- Wifi ---> local leader
                            First-leg Wifi packet:
                            - type: Packet.CLIENT_REQUEST
                            - subtype: Packet.CLIENT_DOWNLOAD_PHOTO
                            - a unique requestCounter based on the IP address (mId) of Phone A
                            - a byte stream of a GetPhotoInfo object for tracking, throughout different stages of the request
                              GetPhotoInfo object:
                                - originNodeId: the IP address (mId) of Phone A
                                - srcRegion: source region of Phone A (1)
                                - destRegion: destination region (5)
                                - requestCtr: the unique requestCounter 

Phone B:
5. Mux.java processMessage() hears the message, figures out that it has `case Packet.CLIENT_REQUEST`, and forwards the package to UserApp's handleClientRequest.
6. UserApp.java: handleClientRequest()
        is used by a leader to handle the first-leg of the request initiated by one of its non-leaders. First, handleClientRequest() makes sure that the Wifi packet is in fact from its own region and then it makes sure that the requestCounter of the Wifi packet has not been encountered before.
7.      After making sure that the Wifi packet is new, different actions are taken based on the subtype of the Wifi packet. In our case of Packet.CLIENT_DOWNLOAD_PHOTO, first the destination region of the request is retreived from the GetPhotoInfo bytes.
8.      Then a DIPLOMA atom request, with procedure `SERVER_GET_PHOTO`, is made and sent to the destination region (5). The atom request also contains the unmodified GetPhotoInfo bytes from the Wifi packet.
9.      A first-leg ack is sent to Phone A through a new Wifi packet. If this ack is lost or if the first leg failed, Phone A's StatusActivity.java will repeatly send the first leg Wifi packet 4 times (see step 5) or until its StatusActivity hears this first-leg ack.
            First-leg ack Wifi packet:
                - type: Packet.SERVER_REPLY
                - subtype: Packet.SERVER_FIRST_LEG_ACK

* Second Leg: *                           Phone B --- DIPLOMA ---> Phone C
                                     local leader --- DIPLOMA ---> remote leader
                                                  Second-leg DIPLOMA atom request:
                                                  - procedure: SERVER_GET_PHOTO
                                                  - GetPhotoInfo object
                                                        - same as First-leg Wifi packet's GetPhotoInfo object

Phone C:
10. Through DIPLOMA, the atom request is sent to Phone C, the leader of the destination region of the user request, which in this scenario is region 5. 
11. UserApp.java: handleDSMRequest()
        executes the user request. Different tasks are performed depending on what the atom request procedure is. A user request of getting photos correspond to the SERVER_GET_PHOTO procedure.
12.     Inside the case SERVER_GET_PHOTO, Phone C retrieves the photo byte array from its region's consistent shared memory: block.lines (see DSMLayer.java for details). Since block.lines is a hash map, all photo data are grouped under the same key, `Globals.PHOTO_KEY`. This key then points to the ArrayList of photos, where we get the newest photo. Currently there is only one element in the ArrayList that is constantly updated to contain the newest photo of the region.  
    TODO!!
    See XX for more details.. 
        Since only the newest photo of the region is retrieved, it might seem strange that only the first element of the photo Arraylist is updated. Initially, the app's UI was designed to be able to retrieve the ith newest photo. So it is indeed superfluous to store the newest photo's byte array in an Arraylist, but this design allows a simpler change if in the future the app should save multiple photos.
13.     Regardless of whether a photo exists in the remote region or not, the success flag, `isSuccess`, is set to true because the remote leader has successfully executed the request (as compared to the request timed out on the local leader, see step 33).
14.     If a photo exists, its data is set to GetPhotoInfo byte's photoBytes field. If there is no data info, the photoBytes filed is set to null.
15.     A DIPLOMA atom reply is made with the same procedure as the atom request (`SERVER_GET_PHOTO`), but reversed destination and source regions. The atom reply also contains the modified version of the atom request's GetPhotoInfo, with photoBytes set. This atom reply is send from the remote leader back to the local leader through DIPLOMA, as the third leg of the request.

* Third Leg: *                           Phone B <--- DIPLOMA --- Phone C
                                    local leader <--- DIPLOMA --- remote leader
                                                  Third-leg DIPLOMA atom reply:
                                                  - procedure: SERVER_GET_PHOTO
                                                  - GetPhotoInfo object:
                                                        - same information as First-leg Wifi packet's GetPhotoInfo object
                                                        - photoBytes: set to bytes of picture (or null if no picture in region)
                                                        - isSuccess: true for successful retrieval

Phone B:
16. UserApp.java: handleDSMReply() of the local leader (Phone B)
        processes the Atom reply from the the remote leader (Phone C) to figure out a) the IP address of the original phone and b) whether the atom request timed out
17.     a) The original phone's IP address is extracted from the atom reply GetPhotoInfo object's originNodeId field. The IP address is required to send a final Wifi packet back to the originator phone node. This Wifi packet contains the same GetPhotoInfo objects as the atom reply with the addition of the isSuccess field set to indicate whether the atom request timed out.
18.     b) An atom request times out if the local leader (Phone B) cannot reach the remote leader (Phone C) with DIPLOMA, in which case the local leader will send a fake self reply with the reply atom's `timedOut` field set to `true` (see DSMLayer.java). (This timed out case is not represented by the above Third Leg diagram, the DIPLOMA atom reply would be a self-loop on the local leader instead.) When a reply is detected to be timedOut inside handleDSMReply(), the GetPhotoInfo object's isSuccess is set to false.
19.     A reply counter is constructed based on the request counter to keep track of all the Wifi reply packets.
20.     From the procedure of the atom reply, handleDSMReply() sets subtype of the final Wifi reply packet.
21.     The Wifi reply is put into a hash map, `replyPacketMap`, to repeatedly send a reply until the originator acknowledges its acceptance.
22.     The Wifi reply is send through the `sendReplies` function.
23. UserApp.java: sendReplies() is a function to send Wifi replies every sendingRepliesPeriod until Phone B receives the final leg ack from the client or the sendingRepliesTimeoutPeriod is reached. 
24.     The only parameter of `sendReplies()` is the reply counter, which is used to create two custom runnables, one for the reply, one for the reply timeout. The functions createReplyRepeatingRunnable() and create ReplyTimeoutR() are basically runnable wrappers to make the runnables take in different reply counter parameters.
25. UserApp.java: createReplyRepeatingRunnable() retrieves the Wifi packet from the hash map to finally send it. At the end of the function it posts itself to the handler to be called every sendingRepliesPeriod.

* Fourth Leg: *     Phone A <--- Wifi --- Phone B
                 originator <--- Wifi --- local leader
                            Fourth-leg/Final Wifi packet:
                            - type: Packet.SERVER_REPLY
                            - subtype: Packet.CLIENT_SHOW_REMOTEPHOTO
                            - a unique requestCounter based on the IP address (mId) of Phone A
                            - a unique replyCounter based on requestCounter
                            - a byte stream of a GetPhotoInfo object for tracking, throughout different stages of the request
                              GetPhotoInfo object:
                                - same information as Third-leg DIPLOMA packet's GetPhotoInfo object
                                - isSuccess: false if DILPOMA level timed out

Phone A:
26. StatusActivity.java: myHandler handleMessage() 
        receives messages from its Mux and sorts the packets by its subtype.
27.     In our case of CLIENT_SHOW_REMOTEPHOTO, first the current time is noted to calculate the latency by subtracting the start time from step 5.
28.     Remove the timeout runnable and enable button presses again.
29. StatusActivity.java: finalLegAck()
        The final leg ack is sent to Phone B, the local leader, through a new Wifi packet. If this ack is lost or if the first leg failed, Phone B's reply repeating runnable (step 25.) repeatly send the final Wifi packet until the sendingRepliesTimeoutPeriod is reached or it hears this final-leg ack. This final leg ack is sent even for duplicated Final Wifi packets received, such as in the case of a previously lost final leg ack.
            Final-leg ack Wifi packet:
                - type: Packet.CLIENT_REQUEST
                - subtype: Packet.CLIENT_FINAL_LEG_ACK
                - a unique requestCounter based on the IP address (mId) of Phone A
                - the replyCounter received from the Final Wifi packet
30. StatusActivity.java: myHandler handleMessage() case CLIENT_SHOW_REMOTEPHOTO
        The packet reply counter is checked with an array list of processed reply counters. If found, that means the packet is a duplicate. Else, the reply counter is added to the array list and the packet proceeds to be processed.
31.     The GetPhotoINfo object from the packet contains the actual photo bytes of the remote photo. Its `isSuccess` field contains information on whether the packet timed out at DIPLOMA or not. If so, we increment the counter for "bad" requests, `getBad`.
32.     Regardless of the region having a photo or not, as long as DIPLOMA did not time out, the counter for successful requests, `getGood`, is incremented.

Phone A does not receive reply from Phone B:
33. StatusActivity.java: buttonEnableProgressDownloadTimeoutR
        There are times when the local leader is not available, possibly due to the leader switching regions but before a new leader is elected or sometimes the Wifi connection is not consistent. In such cases, the originator may never hear a reply from the local leader, i.e. Phone A never receives  the fourth and final leg Wifi Packet. Since UI is blocked as soon as buttons are pressed (step 2), this timeout is set up to enable the UI buttons again as well as record down the number of time outs in counter `getTimedout`.

#########################################################
#########################################################

Camera_DIPLOMA Scenario 4. Leader of region 1 getting region 5's photo. 
------
Phone B: request originator is the leader of region 1 in this scenario
Phone C: leader of remote region, in this scenario, region 5's leader

The entire walkthrough is the same as Scenario 3, except "Phone A"'s StatusActivity roles are also run on Phone B, which is already performing the leader UserApp roles. See Scenario 2's diagram.


#########################################################
#########################################################

Camera_CLOUD details
=================

Compared to Camera_DIPLOMA, Camera_CLOUD is a much simpler app.


-------------------------
|   File Name                           lines**     Description
-------------------------
|   CameraCloud.java                    1200        Where the app starts. UI of app. Connections to the cloud
|   CameraSurfaceView.java               100        Camera UI
|   Globals.java                          70        Global variables 
|   HysteresisSpinnerListener.java        20        UI, to set width of hysteresis in real-life deployment
|   RegionKey.java                        50        Region key class
|------------------
|   Total                               1400    
|------------------
 
Regions only nominally exist in Camera_CLOUD, each phone behaves independently. There are no leaders or nonleaders. Each TAKE and GET request is very similar, with just one roundtrip to the cloud server to save or retrieve information.

Scenario 1. Cloud Take
----------------------
1. User presses the "Take Photo" button on phone.
2. CameraCloud.java: my_camera_button OnClickListener() 
        registers the button press and disable all other button presses with ProgressDialog until response is received in step 10.
3. CameraCloud.java: HandlePictureStorage() gets the byte array of the photo
4. CameraCloud.java: sendClientNewpic() compresses the photo 
5. CameraCloud.java: serverRequest() sets up an Http connection to the cloud server 
6.      The time is taken down for latency calculations
7.      An HttpPost with the photo data (and others, see diagram below) is executed via 3G or 4G.
8.      If there are any exceptions that would cause the HttpPost to not execute, the `takeException` counter is incremented.
9.      In the case that there is a response, the `takeGood` counter is only incremented if there is not a null response, errorneous return status. Otherwise, `takeBad` is incremented.
10.      Latency is calculated
11. CameraCloud.java: sendClientNewpic() enables UI button presses again

        Phone  ------ 3G or 4G ------> Cloud
                HttpPost data:
                - CLIENT_UPLOAD_PHOTO
                - Region number 
                - Photo byte array
    

Scenario 2. Cloud Get Region 5
---------------------------
1. User presses the "Get 5 Photo" button on phone.
2. CameraCloud.java: get_button_listener OnClickListener() 
        registers the button press and knows the destination region is 5 and disable all other button presses with ProgressDialog until response is received in step XX
4. CameraCloud.java: serverRequest() sets up an Http connection to the cloud server 
5.      The time is taken down for latency calculations
6.      An HttpPost with the photo data (and others, see diagram below) is executed via 3G or 4G.
8.      If there are any exceptions that would cause the HttpPost to not execute, the `getException` counter is incremented.
9.      In the case that there is a response, the `getGood` counter is only incremented if an actual photo is successfully received. So the "bad" counter is incremented in all other responses, such as null response, errorneous return statuses, or if a region does not have a photo.
10.      Latency is calculated
11. CameraCloud.java: get_button_listener enables UI button presses again

        Phone  ------ 3G or 4G ------> Cloud
                HttpPost data:
                - CLIENT_DOWNLOAD_PHOTO
                - Region number 

Cloud can't distinguish between a region without any phones and a region with phones but haven't uploaded any pictures yet. Both of these cases would result in a failure when trying to get from this region. This is because the cloud only knows the existence of a region (by creating an entry in its dictionary) when the first picture of a region is uploaded.  Unlike in CameraDIPLOMA where leaders inform the cloud when they're being created or are leaving.

Similarly, since phones on CameraCloud don't inform the cloud that they're going out of a region, as soon as the first picture of a region is uploaded, it will be possible to get photos from that region even if the phone leaves that region.

-------

DIPLOMA
bad = (isSuccess == false): some or all of this is due to DIPLOMA Level time out
timedOut = timed out after 6 seconds. If request comes back after 6 seconds, it is counted into getGood or getBad

################
################

Code Set Up
==============================

- The IP addresses of the phones should only differ in their last number. Their identical first 3 numbers should also be set for the first 3 numbers of Globals.BROADCAST_ADDRESS. During my project. the phones had IP addresses of 192.168.5.[number], so the Globals.BROADCAST_ADDRESS was set to "192.168.5.255" 
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/c96695f6d4246bedc1395cffac9e184e807ba53e#L1R16

- 

Experiment Set Up
==============================
- Run DIPLOMA and Cloud servers and make sure their IP addresses are set on Globals.CSM_SERVER_NAME and Globals.CLOUD_SERVER_NAME respectively.
- Start Barnacle on DIPLOMA phones
- The first time Barnacle starts it'll ask for WPA Supplicant. Keep choosing "Yes" and it will create the WPA supplicant.
- On March 10th, we observed Barnacle printing an error saying : "Cannot put eth0 in ad-hoc mode" on the AT&T phone but it still continues to work fine. We do not observe this error later on.
1. SMCloud server running ?
2. DIPLOMA server running ?
3. Ensure Items 1 and 2 above do not run on the same port on the same machine.
4. The code on the phone must point to the right server in both cases
1 and 2 above.

- If the request is taking too long, you might see: "xxx is not responding. Would you like to close it? 'Wait' 'Okay'". If people press 'Okay'. the app crashes. If people press 'Wait' the app continues normally. Don't press anything else

- the logs are saved on the sd card, look for csm*

Notes in chronological order
==============================
- Whenever after the phone connects to USB, you have to turn on the development mode again.

- Socket-already-in-use problem when loading new code is fixed by always killing (using back arrow) the app before loading new code. (The "home" button only pauses the app, not destroying it.)
    Jason: The socket in use is probably due to the NetworkThread not exiting cleanly or at all when you load new code onto it. When you load new code directly from your laptop without first closing the running app by hitting the back button, ADB kills the StatusActivity without letting it close the NetworkThread first.

- Before I used my own CameraSurfaceView, I used the built-in camera ACTION_IMAGE_CAPTURE intent to get the picture: https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/e61381eda31d567bb31c69c21f54d3adb9c9f044/src/edu/mit/csail/diplomamatrix/StatusActivity.java#L382. Initially there was a problem that the simple way of retrieving images only provided a *tiny thumbnail of the image, not the full image*: see https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/a1398a4723c0e6710a43dddb8681081c910875ff/src/edu/mit/csail/diplomamatrix/StatusActivity.java#L364
    The problem is also described here: http://stackoverflow.com/questions/1910608/android-action-image-capture-intent
More specifically, the onActivityResult() of intent image capture can only provide a low-resolution thumbnail because there probably isn't enough storage space all the time to save all the image data. So that's why http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE says that EXTRA_OUTPUT should be used to save the image.
To fix this problem (ultimately I changed into Camera Surface View though and don't use the camera intent at all), I save the new photo on the SD card and onACtivityResult() uses _getAndResizeBitmap() to retreive the photo and resize it. https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/e61381eda31d567bb31c69c21f54d3adb9c9f044#L4R384

- GPS is accurate within 3-5 meters. Each phone has a different consistent offset, e.g. a phone could always be 2 meters more south than the other phones.
- Sometimes the GPS will have a glitch and jump suddenly to a ridiculous location, but this happens so rarely and we don't need to do anything about it

- On March 10th, Anirudh and HaoQi went to check out the stretch of Mass Ave outside of McDonalds and Cafe Luna to get measurements for the 1st experiment. Since that stretch of Mass ave was very straight and we were not yet aware of the limitations of the Wifi range, we thought we could just use the x coordinates of the phones (already rotated so that the axes correspond to east-west and north-south directions) with region 1 starting at the right (south eastern) most region of the road and the regions increase westwards (northwestward of the road).  The regions shapes are not rectangles, but parralelograms (which we'll change to rectangles later so that region width can increase).

    GPS Results from our micro-measurements (NOT USEFUL, but for a record. Later on we discovered there are too many Wifi hotspots causing too much interferance in this stretch of the road)
        A picture from the measurement, you can also see the UI at that time: https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/6c7252d3d9f66a57e3ed84d0135ab021846a1e10/docs/2012_03_10_diploma.JPG
        Google Maps puts the distance between Bank Of America (BOA) and Desi Dhabha on Mass Ave at 0.3 miles which is 540 m
        From Google Maps
            42.363404,-71.100214 Desi Dhaba
            42.366067,-71.104761 BOA 
            Assuming coordinates are planar : distance is 528 m, 10^(-5) degrees is 1 m.
        From phones :
            BOA
                Nexus S :
                42.366300,-71.104936
                Galaxy Note :
                42.365944,-71.104888
                Not instantaneous, they were not taken at the exact same location or time, we moved in about a 5 m radius :
                GPS error between phones ~ sqrt(36^2+5^2)  ~ 37 m  which is kind of ok given that we may have moved quite a bit.
            Desi Dhabha :
                Nexus S:
                -71.100005,42.363466
                Galaxy Note :
                -71.100005,42.363492
                exact same location
                Difference is ~ 3 m That's really accurate between two phones
        Summary of Distances.
            Distance acc to GMaps: 528 m
            Distance acc to Nexus S : 568 m
            Distance acc to Galaxy Note : 546 m

- (very minor ui) `photoResultNull.setVisibility(View.VISIBLE);` of https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/8de606e548b4854807ea91a4822b7638a250843c didn't work so I stopped using it.

- **Important!** https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/333ea188283ab9b67b03c5343ecdc35c01e9fda8#L8R208
    This commit is when I switched from using camera intent to retrieve the picture and saving the pic on the SD card --to--> using the CameraSurfaceView class http://code.google.com/p/openmobster/wiki/CameraTutorial.
    The reason for this change was because the *intent/sd card solution only works on Nexus S phones, not Galaxy Notes* phones. In Galaxy Notes, the Mux is killed and restarted before and after the camera intent (because StatusActivity is paused), causing a "Cannot open socketAddress already in use" error: https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/8de606e548b4854807ea91a4822b7638a250843c/logcats/galaxy_note_camera_crash.txt#L470
    CameraSurfaceView fixes this problem because StatusActivity never has to be paused when taking a photo. Since it works on both types of phones, we used this solution for both.

- ! Much better GPS to region logic, with help from lfei. https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/460a917a4a73594ddd3b48c4109a36935c23c3d1 This takes into account that longitude distances varies greatly from the poles (0) to equator (longest). So the regions can be assigned more accurately. The regions are square. The road is defined by 2 points. (So the road must be straight.)  The final implementation of this in the latest code can be tweaked more easily.


Experiments
==============================

We conducted two pre-experiments to see the app was working and to test the wifi range of the phones.

Pre-experiment 1: 3-phone test to check DIPLOMA relay and Wifi range
    There were 3 people, each holding a phone. One phone stood at a corner of a building while the other phones each stood about 20 meters along a different wall. The middle phone is in range of the other two phones, but the other two phones are not in range with each other, in Wifi and sight. The phones were held vertically, the outer phones faced the middle phone. There were no obstructions in the path of transmission. We would later find out that the range from this test would be too optimistic for multi-user experiments where users moved around and obstructed each other all the time.
    Let the outer phones be A and C, and the inner phone be B. Phone A would take a picture and let phone B know (by using gestures) that B can tell C to request A's picture. If A successfully gets B's photo, then DIPLOMA multi-hop works because the only way for A to succeed is for B to help pass along the picture from C to A in DIPLOMA.  
    When we stood 20 meters apart, the "get" worked about 2 out of 4 times.

Pre-experiment 2: Testing that phones can hear each other across Mass Ave.
    Even though all of the outdoor experiments were conducted on one side of the rode, we tested that Wifi signal could potentially work between phones across the road.  Two of us stood at opposite sidewalks taking and getting each other's picture. We did not observe anything abnormal in the 5 minute experiment. 


   We performed a total of 6 data-collection experiments in a span of almost 2 months. Through time, the apps had fewer bugs and more measures to insure successes. However, it was impossible to fix the most critical issue -- the Wifi range and consistency of the phones. The interference of 20 phones carried by 10 people moving simultaneously and randomly made collecting meaningful data infeasible with the current Wifi abilities of the phones. In the final 2 experiments, we resorted to a controlled indoors experiment with minimal Wifi interference and obtained more expected results.

Experiment 1
------------
Location: 77 Massachusetts Avenue
Date: March 15
Weather: Drizzling and cold
Phones: 20 Nexus S
People: 10 People, 1 Cloud, 1 DIPLOMA/person
Regions: 6
Setup: Linear
Files: https://github.com/haoqili/Android_DIPLOMA_CAMERA/tree/master/camera_diploma_exp1_data, 
       https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/master/camera_diploma_exp1_data/diploma_notes.md
       https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/master/camera_diploma_exp1_data/cloud_notes.md

No usable data from this experiment because this this experiment was filled with problems due to insufficient and inadequate stress testing beforehand. There were frequent crashes due to the Camera Surface interface running out of memory, and the users double pressing the buttons. The regions were too large (a lot more than 20 meters) which caused great trouble in phones communicating with each other even in the same region. A smaller bug forced the users to walk to region 0 whenever the apps crashed. The region assignment based on GPS was observed to be robust.

The git commits between this experiment and the next fixed the following:
- Added leader to cloud heartbeat, i.e. fixed the bug where leaders were not sending heartbeats to the cloud
- Fixed region 0 problem, so that after phone crash, the user can restart at any region, not just region 0.
- Added "take photo" ack, i.e. the 4th leg for take photos
- Added latency measurements
- Improved UI by providing toast messages to show errors to users
- Flush the log everytime there is a new write, instead of when the app closes, so that we have logs even when the app crashed. https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/6c95044a8662de19f2d1b6b8d1043e033da5741c#L30R262
- Automatic detection for net name, 

- Fixed double click problem by using ProgressDialog to freeze the UI as well as a boolean to flag whenever a button is clicked.
  The Double Click Problem: 
    Before we tried using the boolean flag, we tried to make the camera surface view better by closing the camera and force closing the app 
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/5827245dd39eddd7d6097caa2ff10b5949a73448#L7R35
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/5827245dd39eddd7d6097caa2ff10b5949a73448#L7R72
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/017939513daeb33cd9682c717752c89957acc18e#L29R483
    Force closing added to be extra sure nothing bad happens, because we learned that the camera crash problem is caused by camera not being killed even though DIPLOMA has forced stopped and destroyed.
    http://stackoverflow.com/questions/2092951/how-to-close-android-application/5036668#5036668
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/6c95044a8662de19f2d1b6b8d1043e033da5741c#L30R524

    We didn't stress-test these changes independently, but instead tested with the boolean flag that disables all other button presses when a press is made: 
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/5827245dd39eddd7d6097caa2ff10b5949a73448#L11R424 
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/017939513daeb33cd9682c717752c89957acc18e#L29R345
    
    No camera crashes were discovered after these changes

- Progress Dialogs do not stop the popup of "xxx is not responding. Would you like to close it? 'Wait' 'Okay'". If people press 'Okay'. the app crashes. If people press 'Wait' the app continues normally.
  For the Cloud App GETs: ProgressDialog does not show the rotating sphere/darkened screen, but instead just freezes the UI. No harmful effects were observed.
    IRC says: "that dialog shows because your app is not responsive, that is, it won't respond to *system* signals as well"
    It seems true, because the popup only shows if the ProgressDialog's wheel has stopped spinning for a while. This happens if the connection is ultra crappy (indoors).
    Despite being unresponsive for a long time, I haven't seen crashes unless I press 'Okay'.

- Fixed leader hand-off bug by adding a new state "HANDING_OFF"
  Handing_OFF
    We added a HANDING_OFF state, when a leader of one region hands off its leadership.  Here are the diffs we made to VCoreDaemon 
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/eeda40d5f628aa609a5111e02ea1995666b9e451#diff-3

    Here is suvinay's crash logs:
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/5a26e47024fa7630fa3bc86b2107980ddc24482d/logcats/0330_1251/whitephone/suvinay_crash.txt

    The reason we did this was because we (Suvinay/Owen) discovered a consistent problem where before the leader handoff is done, the old leader thinks it's the new region's leader before it even joins the new region. E.g. if the leader of region 3 moves to region 2, this is the sequence of state and region the phone shows:

    Leader (3,0) --> Leader (2, 0) --> JOINING (2, 0) --> Leader (2, 0)

    The second stage (The first "Leader (2,0)") is very short, but if a "Reg # Get" is pressed during this time, the phone freezes because the phone is actually NOT a leader of region 2 yet.

    So we edit it so that it's like

    Leader (3,0) --> HANDING_OFF --> JOINING (2, 0) --> Leader (2, 0)

    Now, we make sure that users can press buttons ONLY if the state of the phone is a Leader or Nonleader:
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/eeda40d5f628aa609a5111e02ea1995666b9e451#L1R350

    HANDING_OFF introduced bug fixes:
    - Make HANDING_OFF able to receive leader nominates and send leader confirmation ack, i.e. making electing new leader possible
        https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/4bdab778fcbc0cd00187eb4bf679946abaa6bec6#L0R333
    - Change the HANDING_OFF state transition to the correct region (important fix)
        https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/4bdab778fcbc0cd00187eb4bf679946abaa6bec6#L0R695

    - Critical fixes in HANDING_OFF so now HANDING_OFF can
        - send heartbeats to nonleaders of the region
            https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/24c58c77e7b762b1a6dfa12689661e1e82846598#L2L143
        - release leadership to the cloud after moving out of old region so that the cloud can accept new leader requests to the old region before the time out of 100 seconds:
            https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/24c58c77e7b762b1a6dfa12689661e1e82846598#L2R246
            https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/24c58c77e7b762b1a6dfa12689661e1e82846598/server_script/diploma_camera_server.py#L84
            - this is one of the causes of *JOINING hanging* because old leaders never could release their leadership to the cloud and allow new leaders to take over. So the only leader transitions occured due to cloud timeouts, after 100 seconds


- Decreased cloud heartbeat, because the old period was too long, which was okay with caching (Jason's old app), but this app doesn't have caching
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/6b3533e98b47b981ed0ba0594f10d4e119caaa92#L4R54

- Improve UI of Galaxy Note by filling up the screen space from about 60% to 100%
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/4ca30c50f7b504a7ac6c5b6cc7cec1eced896860#L0R5

- *N.B.* Galaxy Notes and Nexus S phones require different net names. Galaxy Note needs "eth0" while Nexus S needs "wlan0". Before this commit, I would change the string manually, but this commit allows for automatic detection of the type of phone:
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/4ca30c50f7b504a7ac6c5b6cc7cec1eced896860#L2R486

- OutOfMemoryError
    Another reason that could have contributed to the crash, on the Nexus S phones, was taking too many pictures in a row causing the VM heap to run out of memory at BitmapFactory.decodeByteArray(): 
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/e3e9e5ab069b4f57e6214fd8e6e0300f5d5305cc#L8R325
    http://stackoverflow.com/questions/477572/android-strange-out-of-memory-issue-while-loading-an-image-to-a-bitmap-object
    http://stackoverflow.com/questions/6402858/android-outofmemoryerror-bitmap-size-exceeds-vm-budget
    We observed the memory inside Eclipse's DDMS - Heap profile. 
        The following instructions are from memory, so might not be all correct, consult Google
        Open Eclipse's DDMS
        Left hand side, click on Devices, then click on the icon that dumps HPROF file
        Right hand side click on the Heap tab, and click "Cause GC"
    To reproduce the problem, quickly press back-to-back TAKEs on a Nexus S phone (leader or nonleader)  and there could be a crash on the 3~6th TAKE, after all previous TAKEs are successful
    We observed the free memory fluctuation real time. But we didn't notice a consistent drop in free memory, or consistent decrease of free memory for new TAKE pictures. 
    At first trying catching the exception and putting in  bitmap.recycle() didn't work. 
    Here are the two workarounds that did work
        1. Set the inSampleSize for jpegs to be a big number, so more pixels are skipped and thus it would cause a blurrier and smaller picture:
            https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/dbc267a51799ed40e40751122425e9543e0bd5e8#L1R749
        2. Add garbage collect in many places associated with taking pictures and the memory-intensive resizing the pictures
            https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/dbc267a51799ed40e40751122425e9543e0bd5e8#L1R144
    After these two workarounds were coded, we tested the phone by continuously pressing the TAKEs over 100 times, multiple times, and did not observe any crashes.


- UI improvement: Added counts for success and failures
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/92ccb731dbb4d140001c831602aa7ac570766bd0

- Increased oldLeaderReleasePeriod, because we observed new leader requesting to be leader before the old leader released leadership 
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/1912ef8f3ed2dbd9c887af3038a975681637b42a
- Decreased heartbeatPeriod: https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/b8a64242d4e6974c74d1c86abdfbb277b5e25f60


Experiment 2
------------
Location: 436 Massachusetts Avenue
Date: April 6
Weather: Sunny and cold
Phones: 20 Nexus S, 20 Galaxy Notes
People: 10 People, 1 Cloud, 1 DIPLOMA/person
Regions: 6
Setup: Linear
Files: https://github.com/haoqili/Android_DIPLOMA_CAMERA/tree/master/experiment2_april_6 containing logs, scripts for analysis and power, email conversations
results: https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/master/experiment2_april_6/log_process_aniru_jason/0411c_meeting.txt

The server was started in Stata on hermes5.csail.mit.edu (which we'll discover later that sometimes this drops due to security reasons). The experiment was conducted on the eastern sidewalk of 436 Mass Ave to 2 blocks northwestwards. This stretch of road is very busy, filled with resturants and small businesses, which possibly caused a lot of Wifi interferance with the large number of Wifi hotspots.

Run 1:
We handed 2 Nexus S phones to each of the 10 people, 1 Nexus and 1 Galaxy note. We went through the directions, letting people know that they cannot press "Okay", but press "Wait" instead, if the phone prompts the phone to quit during a request hang. We instructed the people to walk along one side of Mass Ave. The people should press GET/TAKE buttons in the same sequence on both DIPLOMA and Cloud phones.
Observations: When people started to press buttons, the Cloud phone requst made the phone hung for over 2-3 minutes or some phones never stopped hanging.  

We decided to restart the servers. We brought a laptop and tried to connect to a free wifi (which sometimes drops). But we were able to restart the server for run 2.

Run 2:
We had the same phone setup but with Galaxy Notes phones instead of Nexus S phones.
The cloud requests completed within 2-3 minutes, so that was good.
People complained about phones waiting for a long time to JOIN a region. 
People moved around a lot, sometimes forming occasional pairs or triples (to chat with each other). Most of the time half of the regions were unpopulated, which would cause multi-hop problems in DIPLOMA (in additional to bad Wifi range).
We had to restart the server several times.  

Run 3:
Noticing that people were taking a very long time joining a new region, as if each time the server has to time out a region leader to let a new leader in, we decided to have stationary leaders. First we positioned individual people in the different regions and observed that they became leaders of their regions. After all the leaders are set up, we had about 2 non-leader phones as well as all the leaders pressing buttons. The 2 non-leaders could walk around. The pressing buttons period lasted about 5 minutes.

The experimental successes were much higher in Run 3, when there were stationary region leaders. 


Problems:
    - Terrible available Wifi. We observed that pinging sometimes fails even between two phones within an arm's distance. This is probably due to many wifi hotspots interfering with the signals
    - Regions are too big, outside of phone Wifi range, so phones within a region can't hear each other (nonleader can't hear leaders), leaders in adjacent regions can't hear each other either.
    - People held the phones on their palms, horizontally. We found later that this configuration reduced the Wifi range of the phones greatly
    - People were facing different directions. Wifi range is reduced greatly behind a person's back. (During pre-experiments, we pointed the phones at each other, we no obstructions in between.)
    - Many regions were unpopulated in Run 2
    - There were still bugs in the code making leader election after the old leader changes region difficult
    - The server was on the Stata hermes server which sometimes times out
    - The server was controlled by a laptop connecting to a spotty Wifi

RRRRRRRRRRRRRResults
RRRRRRRRRRRRRR
RRRRRRRRRRRRRR

We modified scripts a bit to make it more robust. Currently 3G logs
have been somewhat cleaned up, 4G logs are still a little noisy. In
any case, here are the results after more robust scripts :

4G
Type           Total  Success
diplo-take         80      54
diplo-get          74      15
cloud-take        225     202
cloud-get         345     314

3G

diplo-take         74      73
diplo-get         128      39
cloud-take         70      62
cloud-get         106      95

Note that 3G results have been cleaned up a bit by throwing away
spurious phone logs that weren't part of the experiment.

Latency  in ms :

Notes on Wifi :

mean      558
median    205
std-dev   991

This is after discarding > 6000 ms samples (due to time out).
Conclusion : there are some requests that finish very very late ie in
4 seconds or so. Maybe the phone is overloaded ?

Nexus on Wifi :

mean      263
median    205
std-dev   276

Nexus on 3G :

mean    22546
median  15557
std-dev 20284

Notes on 4G :

mean      837
median    479
std-dev   769

Bandwidth reduction :

For the 3G experiment (Would be good if someone double checked, these
are from the manually-filtered last experiment 3G logs, so they should
be accurate) :

Total count of all bytes corresponding to string "json" in the files
is 158983 bytes. These "json" requests spanned only 5 lines in total,
meaning leader elections were rare. This was the case with the second
experiment There are a total of 74+128, take and get results for
DIPLOMA. The average 3G byte cost per transaction is :
(158983/(74+128)) which is 788 bytes.

On 3G, for each transaction, get or take, there is a request and a
response. The number of bytes in cloud-requests is 976346 in total.
For cloud responses this is a huge 7142626. There are  70 cloud takes
and 106 gets in all. The average 3-G usage per transaction (take or
get ) is  46130 bytes.

Now that the method is clear,here are the 4G results on bandwidth
reduction .I am lapsing in and out of sleep, so will do 4G in the
morning.

===========

4G bandwidth reduction (uncleaned log) :

DIPLOMA :

Total json bytes : 1502405

Cloud : 3819148 + 13375630 (requests + responses) = 17194778

Number of get+take DIPLOMA requests :  Copying from above (80+74) = 154

Number of get+ take Cloud requests :       225+345=570

> diplo-take         80      54
> diplo-get          74      15
> cloud-take        225     202
> cloud-get         345     314

Therefore, 4G bytes per transaction of DIPLOMA is 1502405/154=9755
(considerably larger than 700 for the 3G stuff reported above, because
there people weren't moving)
Similarly, 4G bytes per transaction of CameraCloud is 30166 bytes
(somewhat lower than the 3g value).

===========

First to fill in Niket on this, we prototyped a simple food spotting
application on DIPLOMA over 4G phones (The new Galaxy Notes). Jason
built some power models using the Monsoon power meter and we got some
power measurements on our trace data using that. Here's the summary.
It's a little detailed but it hopefully is clear.

In our 4G experiments, we had people moving around too frequently and
presumably the non leaders could not hear the leaders of the region.
This meant they would not hear 3 consecutive leader heart beats, time
out, go and ask the cloud to see if they could now become leader. But
the cloud still keeps getting hearbeats from the actual leader of the
region. So the cloud rejects all these requests. To enable faster
re-election in case a leader failed (app crashed), we increased the
frequency at which a non-leader contacts the cloud _if_ he can't hear
from the leader. This basically lead to a flood of messages up to the
cloud and back from it rejecting the leader request because as far as
the cloud knows, it's still hearing hearbeats from the real leader.

In terms of actual numbers, there were about ~ 600 request-reject
cycles in the DIPLOMA app. That's 600 odd cloud accesses. The Camera
Cloud version had only about 390 such request-response cycles to the
Cloud. So DIPLOMA actually ended up contacting the cloud way more
often than Camera Cloud. Now, we probably still _may_ (not really
sure) win in terms of number of bytes transferred because DIPLOMA's
request reject cycles were smaller packets while Camera Cloud's
transactions were larger ones with the photo itself.

But, and this is the critical thing, even without calculating, we do
MUCH worse power wise. This is because , from Jason's measurements,
the 4G power profile has a large intercept and small slope. In other
words, the mere fact that you are transmitting a packet consumes more
energy which dwarfs the effect of the packet size. So, to a first
order, packet size is irrelevant. So, DIPLOMA incurs Cloud
request-reject cycles and Camera Cloud incurs only 390. So Camera
Cloud is already doing better. But, this is without including
DIPLOMA's wifi power consumption. If we throw that in, the numbers get
much worse.

We also looked at the second experiment's logs where the 3G nexus
phones were stationary. The number of leader request-reject cycles was
much lower ie 49. So, there I guess we still win, though we don't have
numbers yet. The overall summary is that the 4G results are kind of
unusable due to a combination of mobility and bad wifi. We can run it
again in a better region if you think it will add to the overall story
of the paper.

=====================

Jason and I ran some power measurements on the 3G devices to estimate
power numbers for our 3-g experiment. This is the one in which we
positioned people in regions a priori. We define an access as a
complete HTTP transaction (ie request and response). Here's what we
observed.

For DIPLOMA, 3g accesses are dominated by the leader to cloud heart
beats (every 40 seconds) and non-leaders asking the cloud for
leadership and getting rejected (because there was already a leader).
The second one is a Wifi range issue, just like we observed earlier.
For CameraCloud, each user request for a photo or to upload a photo is
a cloud access.

For DIPLOMA, the average packet size across all 3g accesses is 710
bytes. This has a high standard deviation because all packets are
either very small (signaling for leadership,hearbeat etc) or very
large (photo data). The number of accesses in total is 242.
For CameraCloud, avg. packet size is 12919 bytes and there are 176
such accesses (since there are 176 user requests).

We estimated power consumption for a 710 byte packet and a 12919 byte
packet by sending a stream of 100 packets of each type in two separate
experiments. We got power numbers for both  downloading(methodA) and
uploading packets(methodB) of this size. They turn out to be larger
for the 12919 byte packet but overall, the increase in energy
consumption is dominated by the cost to transmit in the first place.

After all this, we got the average energy per request to be between
1.50(methodA) and 1.72(methodB) Joules for DIPLOMA and between
1.77(methodB) and 2.06(methodA) for CameraCloud. This is w/o Wifi idle
power. So, we do better, but with a disclaimer.

The reason we don't do much better is that our leader hearbeat time is
40 seconds which is pretty aggressive. In total there were 179 such
hearbeats across 202 user requests.

RRRRRRRRRRRRRR
RRRRRRRRRRRRRR
RRRRRRRRRRRRRR

Fixes:

- During the first run, we thought about adding a timeout for the http request on the Cloud App. Then we decided to not do that because we want to show the cloud is slow: 
    https://github.com/haoqili/Android_CLOUD_CAMERA/commit/3b884d8daf67d2bba0980d2bf1c9e6a58810e1af#L0R940

- *N.B.* For Camera Cloud: Before when the server was broken for Run 1, there was an exception in the http request, even though I caught the exception, I didn't re-enable the buttons until there was a response (which was never, after the server failed). This commit catches more exceptions and re-enables buttons inside each of the exceptions:
    https://github.com/haoqili/Android_CLOUD_CAMERA/commit/3b884d8daf67d2bba0980d2bf1c9e6a58810e1af#L0R1008

- Critical HANDING_OFF bug fixes (search for commit 24c58c)

- Decrease region size to 20 meters, the range on side walks outdoor.
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/24c58c77e7b762b1a6dfa12689661e1e82846598#L0R21
    The three of us walked around in different places outdoors with the Galaxy Notes to test ranges. We observed:
        - 20 meters linearly outside of 77 mass ave
        - 25+ meters linearly on Killian court
        - A curved path, like curved behind a tree causes a lot of decrease in range
    At this time, we failed to realize the region size should be small enough so that 2 phones anywhere inside 2 adjacent regions could hear each other, not 1 region. Since the leaders must be able to talk to adjancent leaders. If the region widths are set as the limiting range of the phones (20 meters in our case), the only way a DIPLOMA multi-hop would work is if the leaders are exactly 20 meters from each other. If one leaders just moves a little bit, it will fall out of range of the farther neighboring leader and thus breaking DIPLOMA multi-hops.
    Even though technically the region width should be half of the phone range, with the GPS inaccuracy of the phones, setting the region width to 10 meters is not ideal. If the regions are too small, and the phone's inate GPS inaccuracies varies a lot, we could end up with insensible region allocations. In the worst case, region monotonicity may be broken, e.g. a phone could be erroneously assigned to region 2, between a region 3 and region 4 phone. Without region monotonicity, DIPLOMA multi-hop would not be concrete.
    When we realized this, we made it possible to *change the region's width* from the UI. The default is still 20 meters.
        https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/ae6b6d04f2dde49e2455dfeb72de1037190d9059#L6L831

- Increase the heart beat period to the cloud from 30 seconds to 2 minutes
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/24c58c77e7b762b1a6dfa12689661e1e82846598#L2L35

- Increase the cloud leader retry time. Anirudh: "Increase the retry time out if a non-leader looking to be leader is rejected from the cloud. This prevents a non-leader from being rejected too often by the cloud (which adds to 3-g overhead)."
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/24c58c77e7b762b1a6dfa12689661e1e82846598#L2L37

- Increase the time that the old leader waits to hear back candidate leadership responses. We made this change after discovering, from 4 tests, that in 1 test the leader just barely missed a response.
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/24c58c77e7b762b1a6dfa12689661e1e82846598#L2L39

- Added acks for first and final legs. So that there are 4 chances to make the first leg or final leg succeed. We found that this did not improve results drastically because the 4 sends occur within 1 second, and if the Wifi is down, it's probably not going to get back up within any given second.
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/28a9157f93f3d511a91885c8c9f717a8aca50781
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/c12d180dff17819377c8aa215f5621ddc16be8ee
    
- UI: show number of successes and number of clicks on the UI so that real-time monitoring can be made.
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/7c4752ad5dd5b73a38b7b314a55ac44f499a145c

- Make DIPLOMA time-out detection possible by letting DIPLOMA know about the original client's ID (for its IP address). Before this change, leaders cannot handle the case of timedOut to tell nonclient that I (the leader) failed to reach the remote region so it (the nonclient) doesn't have to wait until its timeout ends. This is because the leader (without its reply.data that contains GetPhotoInfo) cannot distinguish among its nonleaders.
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/3d3438d5c9dd23acc43aa1fcd0870777ba581eee#L0R465

- BTW, we conducted a mini experiment with 6 phones on April 23rd. We ran the server on the laptop we carried, which was connected to the Wifi. The following 6 points were raised:
1. Server code freezes on state upload.
    We couldn't find anything wrong with the server. The most likely case was because the Wifi that the laptop connected to was spotty.

2. Get rid of hysteresis. With hysteresis, there were a few meters around the boundaries of the regions that did not allow the phones to change into a new region. The reason for this was because we were worried that the GPS would be very imprecise and cause phone standing near region boundaries to flicker between 2 regions.  
    However, the downside of hysterisis, compounded with the fact that phones have internal offsets, made everything confusing when the region sizes are now only 20 meters in length. So for a large percentage of a region area, phones next to each other had different regions.
    This caused me to add a hysetrisis selector that defaults to 0, i.e. no hysterisis.
        https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/ae6b6d04f2dde49e2455dfeb72de1037190d9059#L7R614
        https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/89219a4ad3e65f52fd500e6b89b3578cb9831ca7

3. Region size must be same for ccloud and diplo. (because I forgot to update the cloud regions before the mini experiment)

4. Loop back take pictures on the leader must always complete.
    - *N.B.* Moved code order on leaders to have better completion rates for TAKEs. Before, the buttons are enabled after the leader do all the packet processing, during which time the timeout period could have been reached and counted the completed request as a timedout. Now, enabling the buttons is the first thing the phone does after it receives a packet.
        "It was at the very last step because I thought the photo processing should be done first. But I guess the photo processing stuff is either fast enough or it doesn't really conflict with pressing buttons, because I have not seen a failure after" this change
        https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/6164e1ce1699b87bf5a21c724130af9a6d807a19

5. Don't run server on hermes.
6. Associate phones over ad hoc before starting. 

- For testing: added region buttons, so that now we don't have to enter in the region we want to change to inside a textfield
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/06ccef2d0aca89d78715509c167dfc4df964f72e
    This would make us find some bugs in the future becasue now we can change regions very quickly

- Improve performance: if a phone in the JOINING state hears a heartbeat from the region, it tries to become become NONLEADER right away
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/2bc09f5c671413d216fc605a8d3d15b275911e67#L2R295

Experiment 3
------------
Location: 77 Massachusetts Avenue
Date: April 25
Weather: Sunny
Phones: 20 Nexus S, 20 Galaxy Notes
People: 10 People, 1 Cloud, 1 DIPLOMA/person
Regions: 6 or 2
Setup: Linear
Files: 
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/tree/master/experiment3_april_25_2011
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/master/experiment3_april_25_2011/results.txt results

The experiment was conducted strictly on the eastern sidewalk of 77 Mass Ave. Region 0, the first region, starts around the intersection of Amherst St and Mass Ave. Region 5, the last region, ends around 77 Mass Ave. The location is chosen due to its much smaller number of Wifi hotspots compared to busy location last time.

In order to have a more stable server, we used an ethernet-connected laptop and observed no server crashes throughout the experiment. One of us (HaoQi) sat in a classroom overlooking part of the experiment through the window (nothing was seen because during the 1.5 hours of the experiment, a film class was held inside the classroom, with the projector blocking the entire window). Google chat was used for communication. 
The server logs were first logged using tee: `python cloud_camera_server.py | tee cloud1.txt` and `python diploma_camera_server.py | tee dip1.txt`, but the tee separated the server messages and the http messages, and once in every 5-10 minutes dumped all the tee messages at once. Most unfortunately, cloud1.txt and dip1.txt were empty. After this discovery was made, the servers were just ran normally, without the piped tee.

Earlier run: 6 regions 
Later run: 2 regions

    At least one run used Nexus S. At least another run used Galaxy notes.
    At the beginning of each run the server was restarted.
    
    Hysteresis of 0 is used for the entire experiment.
    During a Nexus S run, the regions were switched to 10 meters from 20 meters, but the success rate did not improve (23%).

    Once, there was a case where there were 2 leaders of region 0 (see experiment3_serverlogs/gchat.txt)

    At another point, the cloud seemed frozen so it had to be reset.

    DIPLOMA phones tried to ask to take leadership a lot of the times (most likely due to a code bug).

Results --
We analyzed the data from all runs all at once.

Anirudh:
    At first glance, it doesn't seem to have improved too much. We added a real time counter to the phones to monitor the completion rate on the fly and from inspection, the numbers don't look too good (<40 %) . The latency is really good when it does complete, but any requests across more than one region usually seem to fail.

    Anirudh on results: The only weird aspect is diploma get latency is pretty high ie 1800 ms. It should be comparable to diploma take latency

Found:
- Nexus S: 45% success rate for DIPLOMA, 97% success for Cloud
- Galaxy Notes: 24% success rate for DIPLOMA, 65% success for Cloud
- Nexus S: DIPLOMA get success from own region: 86%, from neighboring region: 7%, for two hops: 6%, for three+ hops: 0%
- Galaxy Notes: DIPLOMA get success from own region: 65%, from neighboring region: 7%, for two+ hops: 0%

Conclusion:
    - Wifi is still bad outside, try experiment indoors next time

Fixes:
    - Disable multi-hop forwarding: 
        https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/a7de3966414044eba905fcc584a77f53c0245789#L4R369

Experiment 4
-----------
Location: Inside Stata, in the lounge closest to the Vassar/Main St intersection    
Date: April 30
Weather: Sunny
Phones: 20 Galaxy Notes ONLY
People: 10 People, 1 Cloud, 1 DIPLOMA/person
Regions: 6 or 4
Setup: 2x3 or 2x2
Files:
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/tree/master/experiment4_april30
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/master/experiment4_april30/results.txt results    

    No GPS, hystersis, DIPLOMA, or multihop. Users simulated regions by pressing buttons according to area on floor. 
    5 runs (run 0 - run 4)
    Jason put on a 3G/4G switch app on the Galaxy Notes, so we only used those phones. During run 2 we used 3G. Otherwise it was all 4G.
    Also during the 3G trial, people started to hold their phones more vertically. 
    
    Observed a bug where sometimes an entire region cannot get/take pictures successfully.

    Run 2, the 3G trial had the best get results of 68% successes, but run 3 had the best get latency of under 800 ms.

Anirudh:
    Run 0 : 4G/ 6 regions : 38 %
    Run 1 : 4G/ 4 regions : 47 %
    Run 2 : 3G/ 4 regions : 68 %
    Run 3 : 4G/ 4 regions : 36 %
    Run 4 : 4G/ 4 regions : 39 %

    Overall, for no good reason, DIPLOMA seems to have higher completion rates when using 3G to get to the cloud as opposed to 4G. There is a  marked improvement when going from 6 regions to 4 regions though. We haven't processed takes yet, but they should be similar. Can we omit 4G altogether in the paper ? Or should we try rerunning 4 regions, indoor with 4G ?

Anirudh:
    Low completion rates are predominantly due to NULL regions (a DIPLOMA timeout) rather than a timeout (a UserApp timeout). The problem is I am not sure how to distinguish between an unpopulated region and a failed DIPLOMA request. Can we ? (see Q&A below)

Fixes:
- Fixed the bug where the entire region cannot get/take pictures. This was due to an error in the ack counter. The reply of a request counter should be derived from the request counter. 
  I made this mistake because it did not occur to me that UserApp does not last from region to region. So if a leader moves and becomes the leader of another region, its UserApp is restarted and the queue that contains all the received replyCounters is reinitialized.
  The standard way of implementing reply counters is to use the request counter, or make a modification based on that. The change is simply one line:
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/aeb358fc5a8f887c4193d7612538f1f1f46ee90c#L3R147
    

Experiment 5
-----------
Location: Inside Stata, in the lounge closest to the Vassar/Main St intersection    
Date: May 6
Phones: 19 Galaxy Notes
People: 2, controlled experiment
Regions: 6
Setup: 
    On the ground supported with car phone stands.

    Region 0            Region 2*           Region 4
    2 DIPLOMA           2 DIPLOMA           1 DIPLOMA    
    2 Cloud             2 Cloud             1 Cloud

    Region 1            Region 3*           Region 5
    2 DIPLOMA           2 DIPLOMA           1 DIPLOMA
    2 Cloud             1 Cloud             1 Cloud
    * I don't remember which hand just 1 phone in region 2 or 3, check the logs yourself
Files:
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/tree/master/experiment5_may6_indoors
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/master/experiment5_may6_indoors/results.txt

We did move the phones around. 

2 Runs
    run 0 was 4G
    run 1 was 3G

Observed that latency was somewhat strange. (See explaination in experiment 6)
Anirudh:
    I am only concerned about the CameraCloud latencies over 3G being too good. I remember seeing a much more perceptible lag. Besides, the TAKES seem to show this as their latency is ~ 1900 ms. Not sure why the GETs are so good for 3G (which is bad for us). Can we re-analyse this log once again before going forward with another deployment ? Surprisingly some of the 3G CameraCloud runs do have good latencies. Maybe it's the effect of caching ? 
Jason: Maybe you pressed buttons too close together, when it was still in active state? Not sure...

Fix:
- Added latency UI so that we can observe the strangeness of latency real time:
    https://github.com/haoqili/Android_DIPLOMA_CAMERA/commit/7df1600531f730d03cc824984ecb21bb60eabd63

Experiment 6
-----------
Location: Inside Stata, in the lounge closest to the Vassar/Main St intersection    
Date: May 12
Phones: 20 Galaxy Notes
People: 2, controlled experiment
Regions: 6 
Files: 
Code: https://github.com/haoqili/Android_DIPLOMA_CAMERA/tree/7df1600531f730d03cc824984ecb21bb60eabd63
Logs and scripts: https://github.com/haoqili/Android_DIPLOMA_CAMERA/tree/master/experiment6_may12_indoors
Results: 
https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/master/experiment6_may12_indoors/results_README.md
https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/master/experiment6_may12_indoors/results_diploma.txt
https://github.com/haoqili/Android_DIPLOMA_CAMERA/blob/master/experiment6_may12_indoors/results_cloud.txt

Setup:
    On 6 chairs

    Region 0            Region 2            Region 4
    2 DIPLOMA           1 DIPLOMA           2 DIPLOMA    
    2 Cloud             1 Cloud             2 Cloud

    Region 1            Region 3            Region 5
    2 DIPLOMA           1 DIPLOMA           2 DIPLOMA
    2 Cloud             1 Cloud             2 Cloud

4 Runs
    Run 2 is trashed because we forgot to turn off the GPS and one leader became dormant during the run.
    We confirmed the warm-up effect in 2.
    So focus on Run 3 and Run 4, where they don't have the "warm-up" effect.


Figured out why latency was strange. Expected results, finally!!

Though for one, DIPLOMA was 3% short of 100%, maybe Wifi was spotty or there was some hard-to-find bug

Closed Questions
=============

Waiting Period
-----------
Q: 
Hi Jason, In VCoreDaemon, what's the purpose of rejoining a region every 10 seconds (stateRequestedTimeoutPeriod = 10000ms) with "Runnable stateRequestedTimeoutR" when we already have "Runnable heartbeatR" to make sure that the leader is alive every 3*heartbeatPeriod time?  

A:
That's in case you're in a "WAITING" state, which is a rest period of
10 seconds or so to make sure we're not just constantly doing leader
request and cloud take leadership cycles too fast.

We can make it shorter though, perhaps.

e.g.

sent leader_req
sent leader_req
sent leader_req
sent leader_req
leader_req timeout
trying to take leadership in cloud
take leadership failed
waiting 10 seconds to cool off / for conditions outside of our control
to change (e.g. mobile data available, out of range, etc.)

v.s.
sent leader_req
sent leader_req
sent leader_req
sent leader_req
leader_req timeout
trying to take leadership in cloud
take leadership failed
redo all the steps above immediately, even though conditions might not
have changed much

Q:
What are the circumstances that would cause a phone to be in a WAITING state?
A:
J: Leader not reachable and unable to take leadership from cloud. Both of those have to be true.

Q:
Should we use caching?
A:
A: This actually ends up hurting performance because of the flood of traffic.

Q:
Can I have a handler in UserApp (to have runnables)?
A:
J: Handlers only work in a separate thread, "UserApp is not it's own thread. You can probably use the handler from another component in the same thread, e.g. vncDaemon.myHandler, which is what DSMLayer does when it needs to post Runnables."

Q:
Could there be multiple threads of UserApp running on a leader?  I.e. if I have global variables (such as a replyCounter) in UserApp, do I need to worry about concurrency issues?
A:
J: No, only one or zero User app is running on a phone.


Q:
I am not sure how to distinguish between an unpopulated region and a failed DIPLOMA request. Can we ?
A:
We can't

Q:
We don't distinguish no camera data / null region for Cloud ? If we do this the CCloud completion rates will probably go up from 97 %
A:
We don't want to distinguish them.



Open Concerns
=============
- ad hoc wifi continues running on the AT&T phones even after we turn off the Barnacle app (assuming we did turn it on once at least to get wifi working in the first place.). ie turning off the barnacle app has no effect on ad hoc wifi on the AT&T phone. Do you know why this is happening ?

- Extremely unlikely race condition (not fixed, we didn't encounter this, though this could happen)
    Chronological order:
    1. The phone makes Request 1 and ProgressDialog is activated to freeze the UI
    2. Request 1 times out so ProgressDialog is disabled and the UI is unfrozen
    3. Right after, the phone makes Request 2 a TAKE, and the ProgressDialog is activated again so UI is frozen again for this request
    4. Request 1's reply comes back and disables any ProgressDialog, which in this case is actually the ProgressDialog to make sure Request 2's TAKE's camera does not have the double click (quickly activating the camera twice crashes the camera, see "Double Click Problem" above) problem.
    5. *Immediately* after the ProgressDialog is disabled, the user clicks on another TAKE, and *could encounter the Doble Click Problem*
    Fixes:
        1. Save latest request id in StatusActivity (in a queue or variable) and only if the request id from the received packet matches the latest request id can the ProgressDialog be dismissed.
        or 2. Independent timeout for camera

- OutOfMemoryError (Search above)

- Never tried:
    Jason: 
    FYI, I just found that we can flash a different radio binary to the
    Galaxy Notes to enable selecting 3G (HSPA+) or 4G (LTE) mode on the
    Galaxy Notes, which would mean we could run both our 3G and 4G
    experiments on the same phones. This would mean we can just use the
    AT&T SIMs and not refill the T-Mobile ones for the Nexus S's.

    For DIPLOMA, though, perhaps we should continue using the Nexus S's
    since that's what was used in the previous experiments, too.

- USB hub that stopped working consistently. If it had worked we could have used this script to run adb on all connected phones:
    Jason:
        #!/bin/bash
        # Script adb+
        # Usage
        # You can run any command adb provide on all your current devices
        # ./adb+ <command> is the equivalent of ./adb -s <serial number> <command>
        #
        # Examples
        # ./adb+ version
        # ./adb+ install apidemo.apk
        # ./adb+ uninstall com.example.android.apis

        adb devices | while read line
        do
           if [ ! "$line" = "" ] && [ `echo $line | awk '{print $2}'` = "device" ]
           then
               device=`echo $line | awk '{print $1}'`
               echo "$device $@ ..."
               adb -s $device $@
           fi
        done

- Why does DIPLOMA do better in 3G than 4G?

- Double leaders occur occasionally